#include "rtc_driver.h"

#define RTC_2_Hz   0xF
#define RTC_MAX_Hz  0x6
#define BYTE_4     4
#define DEFAULT_FREQ    512

volatile static int32_t rtc_int[NUM_TERMS] = {0,0,0};
volatile static uint32_t rtc_freq[NUM_TERMS] = {DEFAULT_FREQ,DEFAULT_FREQ,DEFAULT_FREQ};
volatile static uint32_t rtc_counter[NUM_TERMS] = {0,0,0};
// Assume rtc_init is called only during when kernel initializing, so NO interrupts would occur during this time.
/*
 * rtc_init
 *   DESCRIPTION: Initialize the RTC.
 *   INPUTS: none
 *   OUTPUTS: none
 *   RETURN VALUE: none
 *   SIDE EFFECTS: Turn on RTC with the a rate of 2 Hz.
 */
void rtc_init(){
    outb((RTC_REG_B | NMI_BIT), INDEX_PORT);    // Select register B and also disabled NMI by first bit set to 1.
    uint8_t prev = inb(RTC_PORT_RW);    // Get current value in register B
    outb((RTC_REG_B | NMI_BIT), INDEX_PORT);    // Need to update regsiter B.
    outb((prev|0x40), RTC_PORT_RW);     // Turn on the bit 6 of register B

    // Setup freq to 2Hz
    prev = inb(RTC_PORT_RW);	// get initial value of register A
    outb(RTC_REG_A | NMI_BIT, INDEX_PORT);		// reset index to A
    outb((prev & RTC_HIGH_MASK) | (RTC_MAX_Hz & RTC_LOW_MASK), RTC_PORT_RW); //write rate 2Hz to regsiter A. 15 is the lowest rate we can get for RTC, and it's in the lower 4 bits.
    outb((inb(INDEX_PORT) & (~NMI_BIT)), INDEX_PORT); // Restore/enable NMI bit.

    enable_irq(RTC_IRQ_NUM);    // Enable RTC IRQ line.
}

/*
 * RTC_IRQ_handler
 *   DESCRIPTION: interrupt handler for interrupts generated by RTC.
 *   INPUTS: none
 *   OUTPUTS: none
 *   RETURN VALUE: none
 *   SIDE EFFECTS: none.
 */
void RTC_IRQ_handler(){
    disable_irq(RTC_IRQ_NUM);
    // __asm__ volatile("pushal");
    // Disable NMI
    outb((inb(INDEX_PORT) | NMI_BIT), INDEX_PORT);
    //test_interrupts();
    send_eoi(RTC_IRQ_NUM);

    uint32_t i;
    for(i=0; i<NUM_TERMS; i++){
        // if (rtc_freq[i]!=0){
            rtc_counter[i]++;
            rtc_counter[i]%=rtc_freq[i];
            if (rtc_counter[i]==0){
                // if (rtc_counter[0]==0)  printf("RTC interrupts!\n");
                rtc_int[i] = 1;
            }
    }

    outb(RTC_REG_C | NMI_BIT, INDEX_PORT);    //Select regsiter C
    inb(RTC_PORT_RW);   // Throw away contents. Read register C ensure that we always have next interrupt
    outb((inb(INDEX_PORT) & (~NMI_BIT)), INDEX_PORT); // Restore/enable NMI bit.
    enable_irq(RTC_IRQ_NUM);
    // terminal_printf("Generating RTC interrupts!\n");
    // rtc_int = 1;
    // __asm__ volatile("popal; leave; iret"); //Using IRET instead of RET by gcc
}



/*
 * rtc_open
 *   DESCRIPTION: setup the RTC.
 *   INPUTS: filename
 *   OUTPUTS: none
 *   RETURN VALUE: 0
 *   SIDE EFFECTS: none.
 */
int rtc_open(const uint8_t* filename){
     // Setup freq to 2Hz
    outb(RTC_REG_A | NMI_BIT, INDEX_PORT);  // reset index to A
    uint8_t prev = inb(RTC_PORT_RW);    // get initial value of register A
    outb(RTC_REG_A | NMI_BIT, INDEX_PORT);  // reset index to A
    outb((prev & RTC_HIGH_MASK) | (RTC_MAX_Hz & RTC_LOW_MASK), RTC_PORT_RW); //write rate 2Hz to regsiter A. 15 is the lowest rate we can get for RTC, and it's in the lower 4 bits.
    return 0;
}

/*
 * rtc_read
 *   DESCRIPTION: wait until next rtc interrupt.
 *   INPUTS: none
 *   OUTPUTS: none
 *   RETURN VALUE: 0.
 *   SIDE EFFECTS: none.
 */
int rtc_read(int32_t fd, void* buf, int32_t nbytes){
    rtc_int[curr_term] = 0;
    // BLACK MAGIC LINE!
    terminal_printf("");
    for(;(!rtc_int[curr_term]);){
    };
    rtc_int[curr_term] = 0;
    return 0;
}

/*
 * rtc_write
 *   DESCRIPTION: change the rate of RTC.
 *   INPUTS: buf - new frequency, nbytes - always 4
 *   OUTPUTS: none
 *   RETURN VALUE: -1 if fail. otherwise 4.
 *   SIDE EFFECTS: none.
 */
int rtc_write(int32_t fd, const void* buf, int32_t nbytes){

    uint32_t flags;
    cli_and_save(flags);

    // Check the valid input.
    if (buf == NULL || nbytes != BYTE_4)
        return -1;
    uint32_t new_freq = *((uint32_t*)buf);

    // Check the valid input.
    if (new_freq <2 || new_freq > 1024 || (new_freq&(new_freq-1)) != 0)
        return -1;

    rtc_freq[curr_term] = (1024 / new_freq);
    rtc_counter[curr_term] = 0;

    //Calculate the new rate
    // uint8_t new_rate = 0;
    // while(new_freq != 0)
    // {
    //     new_rate++;
    //     new_freq = new_freq >> 1;
    // }
    // new_rate = 16 - (new_rate - 1);


    // outb(RTC_REG_A | NMI_BIT, INDEX_PORT);  // reset index to A
    // uint8_t prev = inb(RTC_PORT_RW);    // get initial value of register A
    // outb(RTC_REG_A | NMI_BIT, INDEX_PORT);      // reset index to A
    // outb((prev & RTC_HIGH_MASK) | (new_rate & RTC_LOW_MASK), RTC_PORT_RW);

    sti();
    restore_flags(flags);
    return BYTE_4;
}

/*
 * rtc_close
 *   DESCRIPTION: Disable rtc interrupts.
 *   INPUTS: none
 *   OUTPUTS: none
 *   RETURN VALUE: none
 *   SIDE EFFECTS: none.
 */
int rtc_close(int32_t fd){
    // disable_irq(RTC_IRQ_NUM);
    return 0;
}

void rtc_default_rate(){

    rtc_freq[curr_term] = DEFAULT_FREQ;
    rtc_counter[curr_term] = 0;

}
